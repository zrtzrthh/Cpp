# LC刷题

刷题一定要把题目读清楚，md，尤其是字符串中可能有数字空格。

## 链表

多增删，少查找建议使用，链表利于增删元素，查找元素比较麻烦

```cpp
//单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数，将x的值赋给val，next指针为空
};
```

1. 203.移除元素，设置虚拟头结点，注意释放被移除元素的内存，并将temp指针置空，

2. 707设计链表，一定一定搞虚拟头结点dummyHead，遇到链表如果要处理头结点，无脑设置虚拟头结点。

   **反思**：如果在头结点之前加一个结点，那么就要更新头结点，否则下一次使用的头结点就不是真正的头结点！！！！！！！！！！！！！！！！而使用虚拟头结点就没有这个担心，因为我操作头结点只需要操作dummyHead->next就可以了

3. 206.翻转链表，设置一前一后两个指针操作，简单题

4. 24.两两交换链表中的结点，画图更好做，一步一步来

5. 19.删除链表的倒数第N个结点，设置快慢指针，中间相隔N，同时后移，这样快指针指向null时，慢指针一定指向倒数第N+1个结点，操作删去第N个结点（同样设置虚拟头结点，有可能删头结点）

6. 160.链表相交，两个指针，一个先遍历A链表，再遍历B链表，另一个

   先遍历B链表，再遍历A链表，这样当两个指针相同时，一定为相交结点或空结点。（空节点说明不相交）

7. 142.环形链表，如何判断有环，有环如何找起点？

## Hash表

根据关键码的值进行访问的数据结构，

* 可以使用**数组**做hash的题目，例如242.有效的字母异位词，但是如果哈希值较少，并且特别分散跨度大，使用数组会造成空间浪费。
* set结构体，只需要记录是否出现过，而不需要考虑出现次数（这很符合集合的定义）例如349.两个数组的交集
* Vector容器没有find方法，需要使用algorithm库中的find方法

1. 有效的字母异位词 242 简单，思路清楚即可，
2. 数组的交集 349 只考虑有没有 不用考虑元素是否重复，用set
3. 快乐数 202 取数字各位数的方法，验证迭代过程中有无重复，有无出现1，用set
4. 两数之和 1 找出数组中和为目标值的两个整数 并返回下标 要记录数和下标 用map 
5. 四数相加 454 先遍历前两个vector 统计和与相应的次数存在map1中，在遍历后两个vector，寻找map1中有无等于0-（c+d）的值，若有给count加上map1[0-(c+d)];
6. 赎金信 383 同字母异位词 只用考虑ransom中的字符可以由magazine表示出即可 用普通数组就可以
7. 三数之和 15 中等题 要考虑重复问题，单层循环加双指针，要注意第一个指针去重的条件
8. 四数之和 18 中等，双层循环加双指针，注意取到正确结果后left与right指针的移动情况！！！（我就倒在了这里）

## 字符串

字符串库函数：

`std::reverse(s.begin(),s.end())`翻转`[s.begin(), s.end())`内的字符串（左闭右开）

`std::reverse_copy` 函数与 `std::reverse` 类似，但是它不会改变原始容器的内容，而是将结果复制到另一个容器中。这样可以保留原始容器的内容并得到反转后的副本。