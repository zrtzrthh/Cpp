

## chapter1 什么是操作系统

* 控制软件
* 管理应用程序
* 为应用程序提供服务
* 杀死应用程序
* 资源管理（CPU、内存等），协调资源
* 管理外设、分配资源

操作系统的抽象：CPU—进程 磁盘—文件 内存—地址空间

硬件之上，应用程序之下，给应用程序一个抽象的接口

软件的分类：应用软件与系统软件

Windows Linux的界面属于shell，**课程研究的是内核（kernel）**操作系统内核

Kernel — 操作系统内部组件，包括：CPU，物理内存管理，虚拟内存管理（给上层应用提供较大的内存），文件系统管理，中断处理与设备驱动

### Kernel的特征

* 并发（一段时间内有多段程序可以执行）（并行是一个时间点有多段程序可以执行）：多个运行的程序需要OS管理和调度
* 共享：“同时访问”，互斥共享
* 虚拟：CPU—进程 磁盘—文件 内存—地址空间

* 异步：程序的执行是走走停停，但是运行环境相同时，OS保证运行的结果相同

### OS的一些作用

* 操作系统权衡：空间和时间，性能和可预测性，公平和性能
* 管理硬件：硬件管理，资源分配，例如：硬盘速度和CPU 内存相差很多，需要OS平衡

### OS实例

* UNIX BSD家族
* Linux家族
* Windows家族

### OS结构

...

* VMM虚拟机，在OS之下，物理硬件之上，可以虚拟出多个计算机结构

## chapter2 OS的启动

* 计算机体系结构概述

  * DISK：存放OS
  * BootLoader：加载OS（放到内存中去）
  * BIOS：基本IO处理系统
  * POST（加电自检）：寻找显卡和BIOS

* 计算机内存和硬盘布局

* 开机顺序

### 操作系统与设备和程序交互

* 定义
  * 系统调用：应用程序请求OS提供服务（来源于应用程序）
  * 异常：非法指令或其他坏的处理状态（来源于不良的应用程序）
  * 中断：不同硬件设备的计时器和网络中断（来源于外设）

* 处理时间：
  * 中断：异步
  * 异常：同步（比如除以0）
  * 系统调用：异步或同步 （发出请求是同步的，但是返回需求可能是异步的）

* 响应：

  * 中断：持续
  * 异常：杀死或重新执行
  * 系统调用：等待或持续

* 中断处理过程：

  * 硬件方面：查询中断表（看是哪个外设出问题了）
    * 设置中断标记
    * 查询中断号
  * 软件：
    * 保存当前处理状态
    * 中断服务程序处理
    * 清除中断标记
    * 恢复之前保存的处理状态

* 异常的处理过程：

  * 保存现场
  * 异常处理
    * 杀死异常程序
    * 或者重新执行异常指令
  * 恢复现场 

* 系统调用

  例如：标准c库的printf()函数，发出系统调用write()

  一般使用API接口来进行系统调用，例如：

  * Win32 API 用于 Windows
  * POSIX API 用于Linux等
  * Java API

  函数调用与系统调用：应用程序进行系统调用，在栈中实现；系统调用，应用程序和内核要切换堆栈

* 跨越操作系统边界的开销：

  * 执行时间上的开销超过程序调用
  * 建立中断/异常/系统调用与对应服务 例程映射关系的初始化开销
  * 建立内核堆栈的开销（应用程序用的堆栈和内核是不一样的）
  * 验证参数的时间开销（OS不信任应用程序，在进行系统调用时要检查参数）
  * 内核态映射到用户态的地址空间
  * 内核独立地址空间

## chapter3

### 计算机体系结构/内存分层体系

* CPU（运算器，寄存器，缓存，存储管理单元，控制器） 内存 设备（I/O，磁盘等）
  * CPU本身可以访问寄存器 cache等 但是容量较小 访问速度是最快的
  * 主存 速度快 但是没电之后存储的数据全部释放，因此需要永久保存的程序代码等一般保存在硬盘上
  * 硬盘（虚拟内存） 访问速度慢 但是存储多 有没有电都一直存在
* 逻辑空间（操作系统内核）
  * 抽象：逻辑地址空间
  * 保护：独立地址空间
  * 共享：访问相同内存
  * 虚拟化：更多的地址空间 暂时不用访问的数据可以暂时放到硬盘上 
* 物理空间（内存 硬盘等）
* 在操作系统中管理内存的方法
  * 程序重定位
  * 分段
  * 分页
  * 虚拟内存
  * 按需分页虚拟内存
* 实现高度依赖硬件
  * 需要知道内存架构
  * MMU（内存管理单元）：硬件组件负责处理CPU的内存访问需求

### 地址空间和地址生成

* 地址空间的定义：物理地址空间—硬件主持的地址空间，逻辑地址空间—一个运行的程序所用油的内存范围 物理地址空间与逻辑地址空间的映射是需要操作系统来协调的

  * 逻辑地址的生成：例如.c文件编译得到.s文件（这一步就可以在内存或者硬盘中访问了） 汇编得到.o文件 链接得到.exe文件 但是执行必须由（loader程序将硬盘中的数据或者程序放到内存中 CPU才能去执行）

  * CPU执行指令

    1. ALU发出请求（携带逻辑地址参数）
    2. MMU查找逻辑地址对应的物理地址（在本身或者在内存中寻找）
    3. 控制器向主存发出请求，获得物理地址的内容，
    4. 主存把内存中相应的物理地址的内容拿给CPU，执行命令

    OS 的作用：建设映射关系，地址安全检查：保证访问地址安全（不越界访问）

### 连续内存分配

* 内存碎片问题

  * 空闲内存不能被利用 （内部碎片和外部碎片）

  OS管理空闲的和非空闲的内存（通过一些算法）例：

  * 首次适配：

    分配n字节，从低地址到高地址寻找，找到第一个大于等于n的内存字节块

    重新分配时，看自由的分区是否能合并于相邻的空闲分区

    优点：简单、易于产生更大的空闲块，

    缺点：外部碎片、不确定性

  * 最优适配：

    避免分割较大的内存块，最小化外部碎片产生的尺寸，步骤

    1. 按尺寸排列的空闲块列表
    2. 分配需要寻找的合适分区
    3. 重新分配需要搜索及合并于相邻的空闲分区

    优点：简单 小尺寸分配有效

    缺点：外部碎片 重分配很慢 易产生没用的小碎片
    
  * 最差适配：

    拆分大块的内存块，根据size排序，

    优点：中大型尺寸比较合适

    缺点：之后大分区请求无法被分配

  都是简单的内存管理算法，都不是很好，后续有更好的

* 压缩式碎片整理

* 交换式碎片整理（先把暂不执行的程序换到硬盘中去）

## 非连续内存分配（分段，分页，页表）

连续内存分配利用率低，有外碎片，内碎片问题

非连续内存分配的优点：

1. 程序的物理地址非连续
2. 更好地**内存利用**与**管理**
3. 共享代码与数据
4. 动态加载与动态链接

缺点：

1. 建立虚拟地址与物理地址的转换（软件与硬件方案）

两种方法 分段与分页

### 分段（更好的分离和共享）（使用少）

1. 分段地址空间
   * 程序的运行 堆、栈、程序数据、程序text段存在**连续的逻辑地址空间**中，但是在**物理地址空间是分开的**（比如要求某些数据之间是共享的，一些数据可以读写但是另一些只读，这样进行**分段保证数据的安全性**）
2. 段寻址方案
   * 逻辑地址（**段号**和**偏移**）段表中存储逻辑地址段号和物理地址段号的对应关系（起始地址），以及段的长度限制

### 分页（减少内存碎片）

**分页机制不用通过映射计算偏移**

分页是固定的，段一般是可变的

1. 分页地址空间
   * 划分物理内存至固定大小的桢（frame）
     * 页帧号 f
     * 帧内偏移 o （s位 每帧2^s字节）
     * 物理地址 =  2^s * f + o 例如 0000011000000110 16位的地址空间 9位页帧则物理地址=（3,6）=3*2^9+6=1542
   * 划分逻辑地址空间至相同大小的页（page）
2. 页寻址方案
   * 页表 （通过页号对应页帧号）
   * MMU（内存管理单元） TLB（translation look-aside Buffer）

3. 页是连续的逻辑地址内存，帧是非连续的物理内存，不是所有的也都有对应的帧 

**页表**

* 页帧对应 
* 分页机制的性能问题
  * 访问一个内寸单元需要两次内存访问（一次访问页表找对应关系，一次访问数据）
  * 页表可能非常大
  * 处理方法：缓存（catching），间接访问
* 缓存（TLB）（cpu中）缓存近期访问的页帧转换表，若TLB命中，物理页号很快获取，TLB未命中，对应的表项更新到TLB中
* 缩小页表所占空间大小：
  * 二级页表：一级页表中存放着第二级页表的index ，二级列表存frame number帧号
  * 多级页表（页表树）：
* 页寄存器 （反向页表）
  * 利：
* 基于hash计算的反向页表

## chapter5 虚拟内存

把目前不用的程序数据放在硬盘上

1. 虚拟内存的起因：
   * 程序规模增大，存储器增长速度慢
   * 理想的存储器：更大更快更便宜的非易失性存储器。
2. 存储器的层次结构：寄存器（cpu中，很小），cache（高速缓冲存储器，内存中，很小），主存（内存），磁盘（速度慢）
3. 覆盖技术： 不会同时执行的模块共享同一块内存空间，按照时间先后运行![image-20240307195415127](C:\Users\18143\AppData\Roaming\Typora\typora-user-images\image-20240307195415127.png)
   * 缺点：开销：设计开销，如何设计将大程序划分为小程序，增加编程复杂度；覆盖模块从外存装入内存，引入时间开销。

